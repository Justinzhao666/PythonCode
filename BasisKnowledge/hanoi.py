def move(n,a,b,c):			#src tmp des   汉诺塔就是通过tmp，将src的最后一个放到des上
	if n==1:
		print(a,'-->',c)
	else:
		move(n-1,a,c,b) 	#将a上的n-1个盘放到b上  一直递归到（分线上的递归）
		print(a,'-->',c)	#将a上第n个放到c上 -----------完成任务
		move(n-1,b,a,c)		#现在b上有n-1个盘子，而a是空的。转折发生了：b现在是原来的a——src，a现在是tmp，程序现在需要往下递归了（主线上的递归）

move(4,'A','B','C')

#这种理解方式就是看程序理解，并不是汉诺塔递归的本意


# 主线上的递归：将最后一个之前的移到tmp上，	目的是 往des上放的。
# 分线上的递归：							目的不是往des上放的，是为了将源位置最后一个放到目的位置上去做的铺垫。
# 这里面的a,b,c,在执行的时候不一定还是原来的abc了

# 往前想往前想：
# 上面存在两个递归，递归的尽头自然是遇到 1 开始往外return
# 总的目的是a 全部移到 c
# 但这其中经历的 
# src=a tmp=b des=c
# src=b tmp=a des=c
# src=a tmp=b des=c
# .........
# .........
# 不断地角色转换 


# 一个时候
# a-c
# 二个时候
# a-b a-c b-c
# 三个时候
# ac ab cb ac ba bc ac
